# 7 排序

## 7.1 插入排序
### 7.1.1 算法
最简单的排序算法之一是 **插入排序 (insertion sort)** 。插入排序由 N - 1 趟排序组成。对于 p = 1 到 N - 1 趟，插入排序保证从位置 0 到 位置 p 上的元素为已排序状态。插入排序利用了这样的事实：已知位置 0 到位置 p - 1 上的元素已经处于排过序的状态。

在第 p 趟，我们将位置 p 上的元素向左移动，直到它在前 p + 1 个元素中的正确位置被找到的地方。

```java
public static <E extends Comparable<? super E>> void insertionSort(E[] a) {
    int j;

    for (int p = 1; p < a.length; p++) {
        // 位置 p 上的元素存储于 tmp
        E tmp = a[p];
        // p 之前所有更大的元素都被向右移动一个位置
        for (j = p; j > 0 && tmp.compareTo(a[j - 1]) < 0; j--) {
            a[j] = a[j - 1];
        }
        // tmp 被置于正确的位置上
        a[j] = tmp;
    }
}
```

### 7.1.2 插入排序的分析
由于嵌套循环的每一个都花费 N 次迭代，因此插入排序为 O(N<sup>2</sup>)，而且这个界是精确的，因为以反序的输入可以达到该界。循环中元素的比较次数对于 p 的每个值最多是 p + 1 次。

如果输入的数据已预先排序，那么运行时间为 O(N)，因为内层 for 循环的检测总是立即判定不成立而终止。事实上，如果输入几乎被排序，那么插入排序将运行得很快。由于这种变化差别很大，因此值得我们去分析该算法平均情形的行为。实际上，和各种其他排序算法一样，插入排序的平均情形也是 O(N)。

## 7.2 一些简单排序算法的下界
成员是数的数组的逆序 (inversion) 即具有性质 i < j 但 a[i] > a[j] 的序偶(a[i]，a[j])。这正好是需要由插入排序 (隐含) 执行的交换次数。交换两个不按顺序排列的相邻元素恰好消除一个逆序，而一个排过序的数组没有逆序。由于算法中还有 O(N) 量的其他工作，因此插入排序的运行时间是 O(I + N) ，其中 I 为原始数组中的逆序数。于是，若逆序数是 O(N) ，插入排序以线性时间运行。

可以通过计算排列中的平均逆序数得出插入排序平均运行时间的精确的界。如往常一样，定义平均是一个困难的课题。假设不存在重复元素，输入数据是前 N 个整数的某个排列并设所有的排列都是等可能的。在上述假设下，可以得到以下定理：

* N 个互异数的数组的平均逆序数是 N * (N - 1) / 4
    * 意味着插入排序平均是二次的，同时也提供了只交换相邻元素的任何算法的一个很强的下界
* 通过交换相邻元素进行排序的任何算法平均都需要 O (N<sup>2</sup>) 时间。

下界告诉我们，为了使一个排序算法以亚二次或 O (N<sup>2</sup>) 时间运行，必须执行一些比较，特别是要对相距较远的元素进行交换。一个排序算法通过删除逆序得以向前进行，而为了有效地进行，它必须使每次交换删除不止一个逆序。

## 7.3 希尔排序
希尔排序 (Shellsort) 的名称源于它的发明者 Donald Shell，该算法是冲破二次时间屏障的第一批算法之一，不过直到它最初发现的若干年后才证明了它的亚二次时间界。它通过比较相距一定间隔的元素来工作；各趟比较所用的距离随着算法的进行而减少，直到只比较相邻元素的最后一趟排序位置。由于这个原因，希尔排序也被叫做 **缩减增量排序 (diminishing increment sort)** 。

希尔排序使用一个序列 h<sub>1</sub> ~ h<sub>t</sub>，叫做 **增量序列 (increment sequence)**。只要 h<sub>1</sub> = 1，任何增量序列都是可行的，不过有些增量序列比另一些效果更好。在使用增量 h<sub>k</sub> 的一趟排序之后，对于每一个 i 我们都有 a[i] ≤ a[i + h<sub>k</sub>]；所有相隔 h<sub>k</sub> 的元素都被排序。此时称文件是 h<sub>k</sub> 排序的 (h<sub>k</sub> - sorted)。希尔排序的一个重要性质是，一个 h<sub>k</sub> 排序的文件保持它的 h<sub>k</sub> 排序性。

h<sub>k</sub> 排序的一般做法是，对于 h<sub>k</sub> ~ N - 1 中每一个位置 i，把其上的元素放到 i，i - h<sub>k</sub>，i - 2h<sub>k</sub>... 中的正确位置上。一趟 h<sub>k</sub> 排序的作用就是对 h<sub>k</sub> 个独立的子数组执行一次插入排序。

增量序列的一个流行的选择是使用 Shell 建议的序列：h<sub>t</sub> = [N / 2] 和 h<sub>k</sub> = [h<sub>k + 1</sub> / 2]。

```java
public static <E extends Comparable<? super E>> void shellsort(E[] a) {
    int j;

    for (int gap = a.length / 2; gap > 0; gap /= 2) {
        for (int i = gap; i < a.length; i++) {
            E tmp = a[i];
            for (j = i; j >= gap && tmp.compareTo(a[j - gap]) < 0; j -= gap) {
                a[j] = a[j - gap];
            }
            a[j] = tmp;
        }
    }
}
```