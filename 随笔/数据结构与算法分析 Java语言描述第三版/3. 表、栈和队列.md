# 3 表、栈和队列

## 1 表的实现
表需要的操作：

* printList / makeEmpty
* find / findKth
* insert / remove
* next / previous
* ...

### 1.1 表的简单数组实现

对表的所有操作都可以使用数组来实现,创建数组时无需提前估计表的大小。

数组扩容的思想是：创建一个新的数组(原数组长度的两倍)并拷贝原数组中的数据。

```java
int[] arr = new int[10];
...
// 决定扩大 arr
int[] newArr = new int[arr.length * 2];
for (int i = 0; i < arr.length; i++) {
    newArr[i] = arr[i];
}
arr = newArr;
```
    
#### 数组实现表的时间复杂度：

|操作|时间复杂度|
|:---:|:---:|
|printList|O(N)|
|findKth|O(1)|
|insert / remove|O(N)|

### 1.2 表的简单链表实现

为了避免插入删除的线性开销，可以使用不连续存储的链表。

链表的节点不必在内存中相连；每个节点包含元素和到该元素后继元的节点的链 (link) ，我们称其为 next 链，最后一个节点的 next 链引用 null 。

#### 链表实现表的时间复杂度：

|操作|时间复杂度|
|:---:|:---:|
|printList|O(N)|
|findKth|O(N)|

<br>
 
* remove ： 修改一个 next 引用实现
[![](https://mermaid.ink/img/eyJjb2RlIjoiZ3JhcGggTFJcbiAgICBBW0EwXSAtLT4gQltBMV1cbiAgICBDW0EyXSAtLT4gRFtBM11cbiAgICBCW0ExXSAtLi14IENbQTJdXG4gICAgQltBMV0gLS0-IERbQTNdXG4gICAgRFtBM10gLS0-IEVbQTRdXG4gICAgRVtBNF0gLS0-IG51bGxcbiAgICBcbiAgICAiLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCJ9LCJ1cGRhdGVFZGl0b3IiOmZhbHNlLCJhdXRvU3luYyI6dHJ1ZSwidXBkYXRlRGlhZ3JhbSI6ZmFsc2V9)](https://mermaid-js.github.io/mermaid-live-editor/edit/#eyJjb2RlIjoiZ3JhcGggTFJcbiAgICBBW0EwXSAtLT4gQltBMV1cbiAgICBDW0EyXSAtLT4gRFtBM11cbiAgICBCW0ExXSAtLi14IENbQTJdXG4gICAgQltBMV0gLS0-IERbQTNdXG4gICAgRFtBM10gLS0-IEVbQTRdXG4gICAgRVtBNF0gLS0-IG51bGxcbiAgICBcbiAgICAiLCJtZXJtYWlkIjoie1xuICBcInRoZW1lXCI6IFwiZGVmYXVsdFwiXG59IiwidXBkYXRlRWRpdG9yIjpmYWxzZSwiYXV0b1N5bmMiOnRydWUsInVwZGF0ZURpYWdyYW0iOmZhbHNlfQ)
  * A1 -> next = A2 -> next; 或 A1 -> next = A1 -> next -> next;


* insert ： 对新节点进行两次引用调整
[![](https://mermaid.ink/img/eyJjb2RlIjoiZ3JhcGggTFJcbiAgICBBW0EwXSAtLT4gQltBMV1cbiAgICBCW0ExXSAtLi0-IERbQTJdXG4gICAgQ1tYXSAtLT4gRFtBM11cbiAgICBCW0ExXSAtLT4gQ1tYXVxuICAgIERbQTJdIC0tPiBFW0EzXVxuICAgIEVbQTNdIC0tPiBudWxsXG4gICAgXG4gICAgIiwibWVybWFpZCI6eyJ0aGVtZSI6ImRlZmF1bHQifSwidXBkYXRlRWRpdG9yIjpmYWxzZSwiYXV0b1N5bmMiOnRydWUsInVwZGF0ZURpYWdyYW0iOmZhbHNlfQ)](https://mermaid-js.github.io/mermaid-live-editor/edit/#eyJjb2RlIjoiZ3JhcGggTFJcbiAgICBBW0EwXSAtLT4gQltBMV1cbiAgICBCW0ExXSAtLi0-IERbQTJdXG4gICAgQ1tYXSAtLT4gRFtBM11cbiAgICBCW0ExXSAtLT4gQ1tYXVxuICAgIERbQTJdIC0tPiBFW0EzXVxuICAgIEVbQTNdIC0tPiBudWxsXG4gICAgXG4gICAgIiwibWVybWFpZCI6IntcbiAgXCJ0aGVtZVwiOiBcImRlZmF1bHRcIlxufSIsInVwZGF0ZUVkaXRvciI6ZmFsc2UsImF1dG9TeW5jIjp0cnVlLCJ1cGRhdGVEaWFncmFtIjpmYWxzZX0)
  * X -> next = A1 -> next; 或 X -> next = A2;   
  * A1 -> next = X;

## 2 Java Collections API

### Collection 接口
Collection 接口中的一些重要方法如下：
```java
public interface Collection<E> extends Iterable<E> {
    int size();
    boolean isEmpty();
    void clear();
    boolean contains(Object o);
    boolean add(E e);
    boolean remove(Object o);
    Iterator<E> iterator();
}
```

Collection 接口扩展了 Iterable 接口。实现 Iterator 接口的那些类可以拥有增强 for 循环。
```java
// 在 Iterator 类型上使用增强 for 循环
public static <E> void print(Collection<E> coll){
    for (E item : coll) {
        System.out.println(item);
    }
}
```

### Iterator 接口
实现 Iterator 接口的集合必须提供一个 iterator 的方法，Iterator 接口如下：

```java
public interface Iterator<E> {
    // 判断是否存在下一项
    boolean hasNext();
    // 获取下一项    
    E next();
    // 从底层集合中移除返回的最后一个元素
    default void remove() {
        throw new UnsupportedOperationException("remove");
    }
    // 对每个剩余的元素进行一定的操作
    default void forEachRemaining(Consumer<? super E> action) {
        // 判空
        Objects.requireNonNull(action);
        // 如果存在下一项，下一项执行每个元素要执行的动作
        while (hasNext())
            action.accept(next());
    }
}
```

Iterator 接口的思路是，通过 iterator 方法，每个集合均可创建并返回给客户一个实现 Iterator 接口的对象，并将当前位置的概念在对象内部存储下来。

```java
// 使用一个迭代器改写 Iterator 类型上的增强 for 循环
public static <E> void print(Collection<E> coll){
    Iterator<E> itr = coll.iterator();
    while (itr.hasNext()){
        E item = itr.next();
        System.out.println(item);
    }
}
```

#### Iterator 与 Collection 的 remove 方法区别
以 ArrayList 为例：
* Collection 的 remove 方法
    * 必须首先找出要被删除的项。如果知道所要删除的项的准确位置，那么删除它的开销很可能要小得多。
    
    ```java
    // 返回删除 o 是否成功
    public boolean remove(Object o) {
        // 如果 o 为 null,删除第一个被找到 null 元素,返回 true
        if (o == null) {
            for (int index = 0; index < size; index++)
                if (elementData[index] == null) {
                    fastRemove(index);
                    return true;
                }
        }
        // 如果 o 不为 null,删除第一个与 o 相等的元素，返回 true
        else {
            for (int index = 0; index < size; index++)
                if (o.equals(elementData[index])) {
                    fastRemove(index);
                    return true;
                }
        }
        return false;
    }
    
    // 把 index 后边所有元素向前移动一个单位,覆盖被删除的元素
    private void fastRemove(int index) {
        // 此列表被结构修改的次数 + 1
        modCount++;
        // 复制长度
        int numMoved = size - index - 1;
        if (numMoved > 0)
            // 从下标 index + 1 位置开始赋值
            // 复制长度为 numMoved
            // 从下标 index 开始替换
            System.arraycopy(elementData, index+1, elementData, index, numMoved);
        elementData[--size] = null; // clear to let GC do its work
    }
    ```
  
* Iterator 的 remove 方法
    * 直接使用 Iterator (而非通过增强 for 间接使用) 时。如果对正在被迭代的集合进行结构改变(如 add、remove、clear)，那么迭代器就不再合法(并且在其后使用该迭代器时会有 ConcurrentModificationException 异常抛出)。
    * 如果迭代器调用了自己的 remove 方法，那么这个迭代器仍然是合法的。
    
    ```java
    // 获取集合的 Iterator 实例
    public Iterator<E> iterator() {
        return new Itr();
    }
    
    private class Itr implements Iterator<E> {
        int cursor;       // index of next element to return
        int lastRet = -1; // index of last element returned; -1 if no such
        // 修改次数的期望值，初始值为 modCount。
        int expectedModCount = modCount;
        
        // 判断集合有没有下一个元素，即判断下一个要访问元素的索引和集合的大小
        public boolean hasNext() {
            return cursor != size;
        }
        
        @SuppressWarnings("unchecked")
        public E next() {
            checkForComodification();
            int i = cursor;
            // 下标越界
            if (i >= size)
                throw new NoSuchElementException();
            // 令局部数组引用指向外部的 elementData 引用
            Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length)
                throw new ConcurrentModificationException();
            // 指向下一个元素
            cursor = i + 1;
            // 返回 i 指向的元素，并将 i 复制给 lastSet 记录上一个元素的下标
            return (E) elementData[lastRet = i];
        }
        
        public void remove() {
            if (lastRet < 0)
                throw new IllegalStateException();
            checkForComodification();
        
            try {
                ArrayList.this.remove(lastRet);
                cursor = lastRet;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }
        
        // 检查是否有其他线程同时修改
        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }
    }
    ```

总结：

如果调用 Iterator 的 remove() 方法来删除的话，则 iterator 的内部对象个数和原来集合中对象的个数会保持同步，而直接调用集合的 remove 方法来删除的话，集合中对象的个数会变化而 Iterator 内部对象的个数不会变化，当调用 Iterator 的 next 遍历的时候发现集合中的对象的个数和 Iterator 内部对象的个数不同，这样指针往后移动的时候就找不到要迭代的对象。这是报异常的主要原因，但内部对象操作时为了避免这种情况都会通过 checkForComodification 方法检测是否一致，不一致提前抛出异常 ConcurrentModifiedException。