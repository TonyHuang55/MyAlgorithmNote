# 3 表、栈和队列

## 1 表的实现
表需要的操作：

* printList / makeEmpty
* find / findKth
* insert / remove
* next / previous
* ...

### 1.1 表的简单数组实现

对表的所有操作都可以使用数组来实现,创建数组时无需提前估计表的大小。

数组扩容的思想是：创建一个新的数组(原数组长度的两倍)并拷贝原数组中的数据。

```java
int[] arr = new int[10];
...
// 决定扩大 arr
int[] newArr = new int[arr.length * 2];
for (int i = 0; i < arr.length; i++) {
    newArr[i] = arr[i];
}
arr = newArr;
```
    
#### 1.1.1 数组实现表的时间复杂度：

|操作|时间复杂度|
|:---:|:---:|
|printList|O(N)|
|findKth|O(1)|
|insert / remove|O(N)|

### 1.2 表的简单链表实现

为了避免插入删除的线性开销，可以使用不连续存储的链表。

链表的节点不必在内存中相连；每个节点包含元素和到该元素后继元的节点的链 (link) ，我们称其为 next 链，最后一个节点的 next 链引用 null 。

#### 1.2.1 链表实现表的时间复杂度：

|操作|时间复杂度|
|:---:|:---:|
|printList|O(N)|
|findKth|O(N)|

<br>
 
* remove ：修改一个 next 引用实现

  [![](https://mermaid.ink/img/eyJjb2RlIjoiZ3JhcGggTFJcbiAgICBBW0EwXSAtLT4gQltBMV1cbiAgICBDW0EyXSAtLT4gRFtBM11cbiAgICBCW0ExXSAtLi14IENbQTJdXG4gICAgQltBMV0gLS0-IERbQTNdXG4gICAgRFtBM10gLS0-IEVbQTRdXG4gICAgRVtBNF0gLS0-IG51bGxcbiAgICBcbiAgICAiLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCJ9LCJ1cGRhdGVFZGl0b3IiOmZhbHNlLCJhdXRvU3luYyI6dHJ1ZSwidXBkYXRlRGlhZ3JhbSI6ZmFsc2V9)](https://mermaid-js.github.io/mermaid-live-editor/edit/#eyJjb2RlIjoiZ3JhcGggTFJcbiAgICBBW0EwXSAtLT4gQltBMV1cbiAgICBDW0EyXSAtLT4gRFtBM11cbiAgICBCW0ExXSAtLi14IENbQTJdXG4gICAgQltBMV0gLS0-IERbQTNdXG4gICAgRFtBM10gLS0-IEVbQTRdXG4gICAgRVtBNF0gLS0-IG51bGxcbiAgICBcbiAgICAiLCJtZXJtYWlkIjoie1xuICBcInRoZW1lXCI6IFwiZGVmYXVsdFwiXG59IiwidXBkYXRlRWRpdG9yIjpmYWxzZSwiYXV0b1N5bmMiOnRydWUsInVwZGF0ZURpYWdyYW0iOmZhbHNlfQ)
  
  * A1 -> next = A2 -> next; 或 A1 -> next = A1 -> next -> next;


* insert ：对新节点进行两次引用调整

  [![](https://mermaid.ink/img/eyJjb2RlIjoiZ3JhcGggTFJcbiAgICBBW0EwXSAtLT4gQltBMV1cbiAgICBCW0ExXSAtLi0-IERbQTJdXG4gICAgQ1tYXSAtLT4gRFtBM11cbiAgICBCW0ExXSAtLT4gQ1tYXVxuICAgIERbQTJdIC0tPiBFW0EzXVxuICAgIEVbQTNdIC0tPiBudWxsXG4gICAgXG4gICAgIiwibWVybWFpZCI6eyJ0aGVtZSI6ImRlZmF1bHQifSwidXBkYXRlRWRpdG9yIjpmYWxzZSwiYXV0b1N5bmMiOnRydWUsInVwZGF0ZURpYWdyYW0iOmZhbHNlfQ)](https://mermaid-js.github.io/mermaid-live-editor/edit/#eyJjb2RlIjoiZ3JhcGggTFJcbiAgICBBW0EwXSAtLT4gQltBMV1cbiAgICBCW0ExXSAtLi0-IERbQTJdXG4gICAgQ1tYXSAtLT4gRFtBM11cbiAgICBCW0ExXSAtLT4gQ1tYXVxuICAgIERbQTJdIC0tPiBFW0EzXVxuICAgIEVbQTNdIC0tPiBudWxsXG4gICAgXG4gICAgIiwibWVybWFpZCI6IntcbiAgXCJ0aGVtZVwiOiBcImRlZmF1bHRcIlxufSIsInVwZGF0ZUVkaXRvciI6ZmFsc2UsImF1dG9TeW5jIjp0cnVlLCJ1cGRhdGVEaWFncmFtIjpmYWxzZX0)
  
  * X -> next = A1 -> next; 或 X -> next = A2;   
  * A1 -> next = X;

## 2 Java Collections API

### 2.1 Collection 接口
Collection 接口中的一些重要方法如下：
```java
public interface Collection<E> extends Iterable<E> {
    int size();
    boolean isEmpty();
    void clear();
    boolean contains(Object o);
    boolean add(E e);
    boolean remove(Object o);
    Iterator<E> iterator();
}
```

Collection 接口扩展了 Iterable 接口。实现 Iterator 接口的那些类可以拥有增强 for 循环。
```java
// 在 Iterator 类型上使用增强 for 循环
public static <E> void print(Collection<E> coll){
    for (E item : coll) {
        System.out.println(item);
    }
}
```

### 2.2 Iterator 接口
实现 Iterator 接口的集合必须提供一个 iterator 的方法，Iterator 接口如下：

```java
public interface Iterator<E> {
    // 判断是否存在下一项
    boolean hasNext();
    // 获取下一项    
    E next();
    // 从底层集合中移除返回的最后一个元素
    default void remove() {
        throw new UnsupportedOperationException("remove");
    }
    // 对每个剩余的元素进行一定的操作
    default void forEachRemaining(Consumer<? super E> action) {
        // 判空
        Objects.requireNonNull(action);
        // 如果存在下一项，下一项执行每个元素要执行的动作
        while (hasNext())
            action.accept(next());
    }
}
```

Iterator 接口的思路是，通过 iterator 方法，每个集合均可创建并返回给客户一个实现 Iterator 接口的对象，并将当前位置的概念在对象内部存储下来。

```java
// 使用一个迭代器改写 Iterator 类型上的增强 for 循环
public static <E> void print(Collection<E> coll){
    Iterator<E> itr = coll.iterator();
    while (itr.hasNext()){
        E item = itr.next();
        System.out.println(item);
    }
}
```

#### 2.2.1 Iterator 与 Collection 的 remove 方法区别
以 ArrayList 为例：
* Collection 的 remove 方法
    * 必须首先找出要被删除的项。如果知道所要删除的项的准确位置，那么删除它的开销很可能要小得多。
    
  ```java
  // 返回删除 o 是否成功
  public boolean remove(Object o) {
      // 如果 o 为 null,删除第一个被找到 null 元素,返回 true
      if (o == null) {
          for (int index = 0; index < size; index++)
              if (elementData[index] == null) {
                  fastRemove(index);
                  return true;
              }
      }
      // 如果 o 不为 null,删除第一个与 o 相等的元素，返回 true
      else {
          for (int index = 0; index < size; index++)
              if (o.equals(elementData[index])) {
                  fastRemove(index);
                  return true;
              }
      }
      return false;
  }
  
  // 把 index 后边所有元素向前移动一个单位,覆盖被删除的元素
  private void fastRemove(int index) {
      // 此列表被结构修改的次数 + 1
      modCount++;
      // 复制长度
      int numMoved = size - index - 1;
      if (numMoved > 0)
          // 从下标 index + 1 位置开始赋值
          // 复制长度为 numMoved
          // 从下标 index 开始替换
          System.arraycopy(elementData, index+1, elementData, index, numMoved);
      elementData[--size] = null; // clear to let GC do its work
  }
  ```
  
* Iterator 的 remove 方法
    * 直接使用 Iterator (而非通过增强 for 间接使用) 时。如果对正在被迭代的集合进行结构改变(如 add、remove、clear)，那么迭代器就不再合法(并且在其后使用该迭代器时会有 ConcurrentModificationException 异常抛出)。
    * 如果迭代器调用了自己的 remove 方法，那么这个迭代器仍然是合法的。
    
  ```java
  // 获取集合的 Iterator 实例
  public Iterator<E> iterator() {
      return new Itr();
  }
  
  private class Itr implements Iterator<E> {
      int cursor;       // index of next element to return
      int lastRet = -1; // index of last element returned; -1 if no such
      // 修改次数的期望值，初始值为 modCount。
      int expectedModCount = modCount;
      
      // 判断集合有没有下一个元素，即判断下一个要访问元素的索引和集合的大小
      public boolean hasNext() {
          return cursor != size;
      }
      
      @SuppressWarnings("unchecked")
      public E next() {
          checkForComodification();
          int i = cursor;
          // 下标越界
          if (i >= size)
              throw new NoSuchElementException();
          // 令局部数组引用指向外部的 elementData 引用
          Object[] elementData = ArrayList.this.elementData;
          if (i >= elementData.length)
              throw new ConcurrentModificationException();
          // 指向下一个元素
          cursor = i + 1;
          // 返回 i 指向的元素，并将 i 复制给 lastSet 记录上一个元素的下标
          return (E) elementData[lastRet = i];
      }
      
      public void remove() {
          if (lastRet < 0)
              throw new IllegalStateException();
          checkForComodification();
      
          try {
              ArrayList.this.remove(lastRet);
              cursor = lastRet;
              lastRet = -1;
              expectedModCount = modCount;
          } catch (IndexOutOfBoundsException ex) {
              throw new ConcurrentModificationException();
          }
      }
      
      // 检查是否有其他线程同时修改
      final void checkForComodification() {
          if (modCount != expectedModCount)
              throw new ConcurrentModificationException();
      }
  }
  ```

总结：

如果调用 Iterator 的 remove() 方法来删除的话，则 iterator 的内部对象个数和原来集合中对象的个数会保持同步，而直接调用集合的 remove 方法来删除的话，集合中对象的个数会变化而 Iterator 内部对象的个数不会变化，当调用 Iterator 的 next 遍历的时候发现集合中的对象的个数和 Iterator 内部对象的个数不同，这样指针往后移动的时候就找不到要迭代的对象。这是报异常的主要原因，但内部对象操作时为了避免这种情况都会通过 checkForComodification 方法检测是否一致，不一致提前抛出异常 ConcurrentModifiedException。

### 2.3 List 接口、ArrayList 和 LinkedList

List 接口继承了 Collection 接口，其重要的方法如下：

```java
public interface List<E> extends Collection<E> {
    E get(int index);
    E set(int index, E element);
    void add(int index, E element);
    E remove(int index);
    ListIterator<E> listIterator(int index);
}
```

#### 2.3.1 ArrayList 和 LinkedList 的特性和对比

|类|ArrayList|LinkedList|
|:---:|:---:|:---:|
|实现方式|可增长数组|双链表|
|优点|get / set 调用花费常数时间|新项插入和现有项删除开销花费常数时间，<br>能高效处理表两端的项目|
|缺点|新项插入和现有项删除代价昂贵，<br>除非是在 List 末端进行|不容易作索引，对 get 的调用昂贵|
|尾插时间复杂度|O(N)|O(N)|
|头插时间复杂度|O(N^2)<br>(前端添加是一个 O(N) 的操作)|O(N)|
|遍历求和|O(N)|O(N^2)<br>(get() 是一个 O(N) 的操作)|

补充：
* 如果使用增强 for 循环，它对任意 List 的运行时间都是 O(N)，因为迭代器将有效地从一项到下一项推进。
* 两者的搜索都是低效的，对 Collection 的 contains 和 remove 方法的调用均花费线性时间。
* ArrayList 中容量表示基础数组的大小，当需要时它将自动扩容保证具有表的大小。
    * 如果该大小的早期估计存在，那么 ensureCapacity 可以设置容量为一个足够大的量以避免数组容量以后的扩展。
    * trimToSize 可以在所有的 ArrayList 添加操作完成之后使用以避免浪费空间。

#### 2.3.2 如何用 List 的 remove 方法将一个表中所有具有偶数值的项删除？
1. 构造一个包含所有奇数的新表，清楚原表，将奇数拷贝回原表
2. 避免拷贝，直接删除
   1. 思路 1 代码如下： 
      ```java
      // ArrayList 的 remove 效率不高，花费的是二次时间
      // LinkedList 的两个问题：
      //   1) 对 get 调用的效率不高，花费二次时间
      //   2) remove 调用低效，达到位置 i 的代价昂贵
      public static void removeEvensVer1(List<Integer> lst) {
          int i = 0;
          while (i < lst.size()) {
              if (lst.get(i) % 2 == 0)
                  lst.remove(i);
              else
                  i++;
          }
      }
      ```
   2. 改进思路 1，用迭代器遍历表而非使用 get。代码如下：
      ```java
      // 迭代器遍历是高效率的，但是 Collection 的 remove 方法仍然花费线性时间
      // 还会引发 ConcurrentModificationException 异常 
      public static void removeEvensVer2(List<Integer> lst) {
          for (Integer x : lst) {
              if (x % 2 == 0) {
                  lst.remove(x);
              }
          }
      }
      ``` 
   3. 继续改进，迭代器找到偶数值项后，使用迭代器删除
      ```java
      // LinkedList 对该迭代器的 remove 方法调用只需要常数时间，因为迭代器位于需要被删除的节点(或附近)
      // 故 LinkedList 实现只需要线性时间，而非二次时间
      // ArrayList 即使迭代器位于需要被删除的节点上，其 remove 方法仍然开销昂贵，数组的项必须要移动
      // 故 ArrayList 实现仍然花费二次时间
      public static void removeEvensVer3(List<Integer> lst) {
          Iterator<Integer> itr = lst.iterator();
          while (itr.hasNext()) {
              if (itr.next() % 2 == 0)
                  itr.remove();
          }
      }
      ```

#### 2.3.3 ListIterator 接口
ListIterator 扩展了 List 的 Iterator 的功能。previous 和 hasPrevious 使得对表从后向前遍历得以完成；add 方法则将一个新项以当前位置插入表中；set 改变被迭代器看到的最后一个值。

```java
public interface ListIterator<E> extends Iterator<E> { 
    boolean hasPrevious();
    E previous(); 
    
    void add(E e); 
    void set(E e);
}
```

## 3 ArrayList 类的实现

### 3.1 基本类
**(暂时不检测可能使得迭代器无效的结构上的修改和非法迭代器 remove 方法)**
```java
public class MyArrayList<E> implements Iterable<E> {
    // 定义创建的 MyArrayList 的默认大小
    private static final int DEFAULT_CAPACITY = 10;

    private int theSize;
    private E[] theltems;

    public MyArrayList() {
        doClear();
    }

    public void clear() {
        doClear();
    }

    private void doClear() {
        theSize = 0;
        ensureCapacity(DEFAULT_CAPACITY);
    }

    public int size() {
        return theSize;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void trimToSize() {
        ensureCapacity(size());
    }

    public E get(int idx) {
        if (idx < 0 || idx >= size())
            throw new ArrayIndexOutOfBoundsException();
        return theltems[idx];
    }

    public E set(int idx, E newVal) {
        if (idx < 0 || idx >= size())
            throw new ArrayIndexOutOfBoundsException();
        E old = theltems[idx];
        theltems[idx] = newVal;
        return old;
    }

    public void ensureCapacity(int newCapacity) {
        if (newCapacity < theSize)
            return;
        // 存储对原始数组的一个引用
        E[] old = theltems;
        // 为新数组分配内存
        // 泛型数组的创建是非法的，只能创建一个泛型类型限界的数据进行类型转换
        // 这会产生编译器警告，但是这在泛型集合的实现中是不可避免的
        theltems = (E[]) new Object[newCapacity];
        // 旧 -> 新 的拷贝
        for (int i = 0; i < size(); i++)
            theltems[i] = old[i];
    }

    public boolean add(E x) {
        add(size(), x);
        return true;
    }

    public void add(int idx, E x) {
        if (theltems.length == size())
            // + 1 用于大小为 0 的情况
            ensureCapacity(size() * 2 + 1);
        for (int i = theSize; i > idx; i--)
            theltems[i] = theltems[i - 1];
        theltems[idx] = x;
        theSize++;
    }

    public E remove(int idx) {
        E removedItem = theltems[idx];
        for (int i = idx; i < size() - 1; i++)
            theltems[i] = theltems[i + 1];
        theSize--;
        return removedItem;
    }

    public java.util.Iterator<E> iterator() {
        return new ArrayListIterator();
    }

    private class ArrayListIterator implements java.util.Iterator<E> {
        // 要被查看的下一元素的数组下标
        private int current = 0;

        public boolean hasNext() {
            return current < size();
        }

        public E next() {
            if (!hasNext())
                throw new java.util.NoSuchElementException();
            return theltems[current++];
        }

        public void remove() {
            MyArrayList.this.remove(--current);
        }
    }
}
```

### 3.2 迭代器、Java 嵌套类和内部类
1. 内部类是如何工作的？迭代器的思路如下，ArrayListIterator 成为一个顶级类：
   ```java
   // 版本 1 ，不能使用
   // 原因： theItems 和 size() 不是 ArrayListIterator 类的一部分
   public class MyArrayList<E> implements Iterable<E> {
       private int theSize;
       private E[] theltems;
           ... 
       public java.util.Iterator<E> iterator() {
           return new ArrayListIterator<E>();
       }
   }
   
   // ArrayListIterator 是泛型类，它存储当前位置，程序在 next 方法中试图使用当前位置作为下标访问数组元素然后将当前位置向后推进
   // 这里 theltems[current++] 是非法的
   class ArrayListIterator<E> implements java.util.Iterator<E> {
       private int current = 0;
           ...
       public boolean hasNext() {
           return current < size();
       }
       public E next() {
           return theltems[current++];
       }
   }
   ```
  
2. 简单的改进后，迭代器存储 MyArrayList 的引用：
   ```java
   // 版本 2 ，几乎能够使用。
   // 原因： theItems 可见性，它在 MyArrayList 中是私有的
   public class MyArrayList<E> implements Iterable<E> {
       private int theSize;
       private E[] theltems;
           ...
       public java.util.Iterator<E> iterator() {
           return new ArrayListIterator<E>(this);
       }
   }
   
   
   class ArrayListIterator<E> implements java.util.Iterator<E> {
       private int current = 0;
       private MyArrayList<E> theList;
           ...
       public ArrayListIterator(MyArrayList<E> list) {
           theList = list;
       }
   
       public boolean hasNext() {
           return current < theList.size();
       }
       public E next() {
           return theList.theltems[current++];
       }
   }
   ```
   
3. 进一步改进，嵌套类(必须用 static 表示是嵌套类，而非内部类)
   ```java
   // 版本 3，能够使用
   // 迭代器是一个嵌套类，问题在于在原始设计中，当编写 theItems 而不引用其所在的 MyArrayList 时
   // 编译器无法计算出哪个 MyArrayList 在被引用
   public class MyArrayList<E> implements Iterable<E> {
       private int theSize;
       private E[] theltems;
           ...
       public java.util.Iterator<E> iterator() {
           return new ArrayListIterator<E>(this);
       }
   
       private static class ArrayListIterator<E> implements java.util.Iterator<E> {
           private int current = 0;
           private MyArrayList<E> theList;
               ...
           public ArrayListIterator(MyArrayList<E> list) {
               theList = list;
           }
   
           public boolean hasNext() {
               return current < theList.size();
           }
   
           public E next() {
               return theList.theltems[current++];
           }
       }
   }
   ```

4.继续改进成内部类
   1. 当声明一个内部类时，编译器添加对外部类对象的一个隐式引用，该对象引起内部类对象的构造。MyArrayList.this 和 theList 就会引用同一个 MyArrayList。
   2. 在每一个内部类的对象都恰好与外部类对象的一个实例相关联的情况下，内部类是有用的。在这种情况下，内部类的对象在没有外部类对象与其关联是永远不可能存在的。
   3. theList.theItems 的使用可以由 MyArrayList.this.theItems 替代
   
      ```java
      // 版本 4，能够使用
      // 迭代器是一个内部类并存储当前位置和一个连接到 MyArrayList 的隐式链
      public class MyArrayList<E> implements Iterable<E> {
          private int theSize;
          private E[] theltems;
              ...
          public java.util.Iterator<E> iterator() {
              return new ArrayListIterator<E>();
          }
      
          private class ArrayListIterator<E> implements java.util.Iterator<E> {
              private int current = 0;
      
              public boolean hasNext() {
                  // size() 代替 MyArrayList.this.size()
                  return current < size();
              }
      
              public E next() {
                  // theltems[current++] 代替 MyArrayList.this.theltems[current++]
                  return theltems[current++];
              }
      
              public void remove(){
                  // 迭代器的 remove 可能与 MyArrayList 的 remove 冲突，使用必须用 MyArrayList.this.remove
                  // 注意，在该项被删除后，一些元素需要移动，因此 current 被视为同一元素也必须移动，要用 -- 而非 -1
                  MyArrayList.this.remove(--current);
              }   
          }
      }
      ```

