# 4 树
## 4.1 预备知识
### 4.1.1 树的定义
**树 (tree)** 可以用几种方式定义，定义树的一种自然的方式是递归。一棵树是一些节点的集合，这个集合可以是空集；若不是空集，则树由称作 **根 (root)** 的节点 r 以及 0 个或多个非空的 (子) 树组成，这些子树中每一棵的根都被来自根 r 的一条有向的 **边 (edge)** 所连结。

每一棵子树的根叫做根 r 的 **儿子 (child)** ，而 r 是每一棵子树的根的 **父亲 (parent)** 。

在递归定义中可以发现，一棵树是 N 个节点和 N - 1 条边的集合，其中的一个节点叫作根。存在 N - 1 条边的结论是由下面的事实得出：**每条边都将某个节点连接到它的父亲，而除去根节点外每个节点都有一个父亲** 。

每一个节点可以有任意多个儿子，也可能是零个儿子。没有儿子的节点称为 **树叶 (leaf)** ；具有相同父亲的节点为 **兄弟 (siblings)** ；用类似的方法可以定义 **祖父 (grandparent)** 和 **孙子(grandchild)** 关系。

从节点 n<sub>1</sub> 到 n<sub>k</sub> 的 **路径 (path)** 定义为节点 n<sub>1</sub> ，n<sub>2</sub> ，... , n<sub>k</sub> 的一个序列，使得对于 1 ≤ i < k 节点 n<sub>i</sub> 是 n<sub>i + 1</sub> 的父亲。这条路径的 **长 (length)** 是为该路径上的边的条数，即 k - 1 。从每一个节点到它自己有一条长为 0 的路径。注意，在一棵树中从根到每个节点恰好存在一条路径。

对任意节点 n<sub>i</sub>，n<sub>i</sub> 的 **深度 (depth)** 为从根到 n<sub>i</sub> 的唯一的路径的长；因此，根的深度为 0 。n<sub>i</sub> 的 **高 (height)** 是从 n<sub>i</sub> 到一片树叶的最长路径的长；因此所有的树叶的高都是 0 。一棵树的高等于它的根的高。一棵树的深度等于它最深的树叶的深度；该深度总是等于这棵树的高。 

如果存在从 n<sub>1</sub> 到 n<sub>2</sub> 的一条路径，那么 n<sub>1</sub> 是 n<sub>2</sub> 的一位 **祖先 (ancestor)** ，而 n<sub>2</sub> 是 n<sub>1</sub> 的一个 **后裔 (descendant)** 。如果 n<sub>1</sub> ≠ n<sub>2</sub> ，那么 n<sub>1</sub> 是 n<sub>2</sub> 的一位 **真祖先 (proper ancestor)** ，而 n<sub>2</sub> 是 n<sub>1</sub> 的一个 **真后裔 (proper descendant)** 。

### 4.1.2 树的实现
在每一个节点除数据外还要保存一些链，使得该节点的每一个儿子都有一个链指向它。如果直接建立到各(子)节点直接的链接会浪费空间，解决方法是：将每个节点的所有儿子都放在树节点的链表中。

```java
class TreeNode{
    Object element;         // 数据
    TreeNode firstChild;    // 第一儿子
    TreeNode nextSibling;   // 下一兄弟
}
```

![树第一儿子、下一兄弟表示法](插图/4_树第一儿子、下一兄弟表示法.PNG)

### 4.1.3 树的遍历及应用