# 4 树
## 4.1 预备知识
### 4.1.1 树的定义
**树 (tree)** 可以用几种方式定义，定义树的一种自然的方式是递归。一棵树是一些节点的集合，这个集合可以是空集；若不是空集，则树由称作 **根 (root)** 的节点 r 以及 0 个或多个非空的 (子) 树组成，这些子树中每一棵的根都被来自根 r 的一条有向的 **边 (edge)** 所连结。

每一棵子树的根叫做根 r 的 **儿子 (child)** ，而 r 是每一棵子树的根的 **父亲 (parent)** 。

在递归定义中可以发现，一棵树是 N 个节点和 N - 1 条边的集合，其中的一个节点叫作根。存在 N - 1 条边的结论是由下面的事实得出：**每条边都将某个节点连接到它的父亲，而除去根节点外每个节点都有一个父亲** 。

每一个节点可以有任意多个儿子，也可能是零个儿子。没有儿子的节点称为 **树叶 (leaf)** ；具有相同父亲的节点为 **兄弟 (siblings)** ；用类似的方法可以定义 **祖父 (grandparent)** 和 **孙子(grandchild)** 关系。

从节点 n<sub>1</sub> 到 n<sub>k</sub> 的 **路径 (path)** 定义为节点 n<sub>1</sub> ，n<sub>2</sub> ，... , n<sub>k</sub> 的一个序列，使得对于 1 ≤ i < k 节点 n<sub>i</sub> 是 n<sub>i + 1</sub> 的父亲。这条路径的 **长 (length)** 是为该路径上的边的条数，即 k - 1 。从每一个节点到它自己有一条长为 0 的路径。注意，在一棵树中从根到每个节点恰好存在一条路径。

对任意节点 n<sub>i</sub>，n<sub>i</sub> 的 **深度 (depth)** 为从根到 n<sub>i</sub> 的唯一的路径的长；因此，根的深度为 0 。n<sub>i</sub> 的 **高 (height)** 是从 n<sub>i</sub> 到一片树叶的最长路径的长；因此所有的树叶的高都是 0 。一棵树的高等于它的根的高。一棵树的深度等于它最深的树叶的深度；该深度总是等于这棵树的高。 

如果存在从 n<sub>1</sub> 到 n<sub>2</sub> 的一条路径，那么 n<sub>1</sub> 是 n<sub>2</sub> 的一位 **祖先 (ancestor)** ，而 n<sub>2</sub> 是 n<sub>1</sub> 的一个 **后裔 (descendant)** 。如果 n<sub>1</sub> ≠ n<sub>2</sub> ，那么 n<sub>1</sub> 是 n<sub>2</sub> 的一位 **真祖先 (proper ancestor)** ，而 n<sub>2</sub> 是 n<sub>1</sub> 的一个 **真后裔 (proper descendant)** 。

### 4.1.2 树的实现
在每一个节点除数据外还要保存一些链，使得该节点的每一个儿子都有一个链指向它。如果直接建立到各(子)节点直接的链接会浪费空间，解决方法是：将每个节点的所有儿子都放在树节点的链表中。

```java
class TreeNode{
    Object element;         // 数据
    TreeNode firstChild;    // 第一儿子
    TreeNode nextSibling;   // 下一兄弟
}
```

![树第一儿子、下一兄弟表示法](插图/4_树第一儿子、下一兄弟表示法.PNG)

### 4.1.3 树的遍历及应用
树的流行用法之一就是在常用操作系统中的目录结构。假如要列出目录中所有文件的名字，输出格式是：深度为 d<sub>i</sub> 的文件将被 d<sub>i</sub> 次跳格(tab) 缩进后打印其名。算法伪码如下：

```java
// 列出分级文件系统中目录
// 递归
private void listAll(int depth){
1    printName(depth);
2    if(isDirectory()){
3        for each file c in this directory (for each child)
4            c.listAll(depth + 1);
     }
}

public void listAll(){
    // 为了显示根时不进行缩进，需要从深度 0 开始
    // 这里的深度是一个内部簿记变量，而不是主调例程能够期望知道的参数
    listAll(0);
}
```

上述遍历策略叫做 **先序遍历 (preorder traversal)** 。在先序遍历中，对节点的处理工作是在它的诸儿子节点被处理之前 (pre) 进行的。该程序运行时，第 1 行对每个节点恰好执行一次，因为每个名字只输出一次。由于第 1 行对每个节点最多执行一次，因此第 2 行也必然对每个节点执行一次。不仅如此，对于每个节点的每一个子节点第 4 行最后只能被执行一次。但是，儿子的个数恰好比节点的个数少 1 。最后，第 4 行每执行一次，for 循环就迭代一次，每当循环结束时再加上一次。因此，在每个节点上总的工作量是常数。如果有 N 个文件名需要输出，则运行时间就是 O(N) 。

另一种遍历树的常用方法是 **后序遍历 (postorder traversal)** 。在后序遍历中，一个节点处的工作是在它的诸儿子节点被计算后进行的。算法伪码如下：

```java
public int size(){
    int totalSize = sizeOfThisFile();

    if(isDirectory()){
        for each file c in this directory (for each child)
            totalSize += c.size();
    }

    return totalSize;
}
```

如果当前对象不是目录，那么 size 只返回它所占用的区块数。否则，被该目录占用的区块数将被加到在其所有子节点 (递归地) 发现的区块数中去。

## 4.2 二叉树
### 4.2.1 二叉树的定义
**二叉树 (binary tree)** 是一棵树，其中每个节点都不能有多于两个的儿子。二叉树的一个性质是一棵平均二叉树的深度比节点个数 N 小得多，这个性质有时很重要。分析表明，其平均深度为 O(N<sup>1/2</sup>) ，而对于特殊类型的二叉树，即 **二叉查找树 (binary search tree)** ，其深度平均值是 O(log N) 。最坏情况下，这个深度是可以大到 N - 1 。

### 4.2.2 二叉树的实现
因为一个二叉树节点最多有两个子节点，所以我们可以保存直接链接到它们的链。树节点的声明在结构上类似于双链表的声明，在声明中，节点就是由 element(元素) 的信息加上两个到其他节点的引用 (left 和 right) 组成的结构。

```java
class BinaryNode{
    Object element;     // 元素信息
    BinaryNode left;    // 左孩子
    BinaryNode right;   // 右孩子
}
```

当画树时，不要显式画出 null 链，具有 N 个节点的每一棵二叉树都将需要 N + 1 个 null 链。

### 4.2.3 例子：表达式树
**表达式树 (expression tree)** 的树叶是 **操作数 (operand)** ,如常数或变量名，而其他的节点为 **操作符 (operator)** 。我们可以通过递归计算左子树和右子树所得到的值应用在根处的运算符上而运算出表达式树的值。

1. **中序遍历 (inorder traversal)**
    * 递归地打印左表达式，然后打印根处的运算符，最后得到右表达式
2. **后序遍历 (postorder traversal)**
    * 递归地打印出左子树、右子树，然后打印运算符
3. **先序遍历 (preorder traversal)**
    * 先打印出运算符，然后递归地打印出右子树和左子树

#### 4.2.3.1 构造表达式树
一次一个符号地读入表达式。如果符号是操作数，那么就建立一个单节点树并将它推入栈中；如果符号是操作符，那么就从栈中弹出两棵树 T<sub>1</sub> 和 T<sub>2</sub> (T<sub>1</sub> 先弹出) 并形成一颗新的树，该树的根就是操作符，它的左、右儿子分别是 T<sub>2</sub> 和 T<sub>1</sub> 。然后将这棵新树压入栈中。

![构造表达式树](插图/4_构造表达式树.png)

## 4.3 查找树 ADT —— 二叉查找树
二叉树的一个重要的应用是它们在查找中的使用。假设树中的每个节点存储一个整数(所有项互异)。使二叉树成为二叉查找树的性质是：对于树中的每个节点 X ，它的左子树中所有项的值小于 X 中的项，而它的右子树中所有项的值大于 X 中的项

根据树的递归定义，通常是递归地编写对二叉查找树的操作。因为二叉查找树的平均深度是 O(log N) ，所有不用担心栈空间被用尽。

二叉查找树要求所有的项都能排序，树中的两项总可以使用 compareTo 方法进行比较。注意我们不使用 equals 方法，而是根据两项相等当且仅当 compareTo 方法返回 0 来判断相等。

```java
// 二叉搜索树架构
public class BinarySearchTree<E extends Comparable<? super E>> {
    private static class BinaryNode<E> {
        BinaryNode(E theElement) {
            this(theElement, null, null);
        }

        BinaryNode(E theElement, BinaryNode<E> lt, BinaryNode<E> rt) {
            element = theElement;
            left = lt;
            right = rt;
        }

        E element;
        BinaryNode<E> left;
        BinaryNode<E> right;
    }

    private BinaryNode<E> root;

    public BinarySearchTree() {
        root = null;
    }

    public void makeEmpty() {
        root = null;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public boolean contains(E x) {
        return contains(x, root);
    }

    public E findMin() {
        if (isEmpty()) throw new UnderflowException();
        return findMin(root).element;
    }

    public E findMax() {
        if (isEmpty()) throw new UnderflowException();
        return findMax(root).element;
    }

    public void insert(E x) {
        root = insert(x, root);
    }

    public void remove(E x) {
        root = remove(x, root);
    }

    public void printTree() {
        if (isEmpty())
            System.out.println("Empty tree");
        else
            printTree(root);
    }
    
    private boolean contains(E x, BinaryNode<E> t) {
        // 首先对是否空树进行测试，否则就会生成一个企图通过 null 引用访问数据域的 NullPointerException 异常。
        if (t == null)
            return false;

        int compareResult = x.compareTo(t.element);

        // 如果没找到就向子树进行递归调用
        if (compareResult < 0)
            return contains(x, t.left);
        else if (compareResult > 0)
            return contains(x, t.right);
        else
            return true;
    }

    // 递归实现
    private BinaryNode<E> findMin(BinaryNode<E> t) {
        if (t == null)
            return null;
        else if (t.left == null)
            return t;
        return findMin(t.left);
    }

    // 非递归实现
    private BinaryNode<E> findMax(BinaryNode<E> t) {
        if (t != null)
            while (t.right != null)
                t = t.right;

        return t;
    }

    private BinaryNode<E> insert(E x, BinaryNode<E> t) {
        if (t == null)
            return new BinaryNode<>(x, null, null);

        int compareResult = x.compareTo(t.element);

        if (compareResult < 0)
            t.left = insert(x, t.left);
        else if (compareResult > 0)
            t.right = insert(x, t.right);
        else
            ;
        return t;
    }

    // 该程序的效率并不高，因为它沿该树进行两趟搜索以查找和删除右子树中最小的节点
    
    // 如果删除的次数不多，通常使用的策略是懒惰删除 (lazy deletion)：
    //    当一个元素要被删除时，它仍留在树中，只是被标记为删除。
    //    这特别是在有重复项时很常用，因为此时记录出现频率数的域可以减 1
    //    如果树中的实际节点数和 “被删除” 的节点相同，那么树的深度预计只上升一个小的常数
    //    因此，存在一个与懒惰删除相关的非常小的时间消耗
    //    如果被删除的项时重新插入的，那么分配一个新单元的开销就避免了
    private BinaryNode<E> remove(E x, BinaryNode<E> t) {
        if (t == null)
            return t;

        int compareResult = x.compareTo(t.element);

        // 如果节点是一片树叶，那么它可以被立即删除
        // 如果节点有一个儿子，则该节点可以在其父节点调整自己的链以绕过该节点后被删除
        // 复杂的情况是处理具有两个儿子的节点，一般的删除策略是用其右子树的最小的数据代替该节点的数据并递归地删除那个节点
        // 因为右子树中的最小的节点不可能有左儿子，所以第二次 remove 要容易

        if (compareResult < 0)
            t.left = remove(x, t.left);
        else if (compareResult > 0)
            t.right = remove(x, t.right);
        else if (t.left != null && t.right != null) {
            t.element = findMin(t.right).element;
            t.right = remove(t.element, t.right);
        } else
            t = (t.left != null) ? t.left : t.right;
        return t;
    }

    private void printTree(BinaryNode<E> t) {
        if (t != null) {
            printTree(t.left);
            System.out.println(t.element);
            printTree(t.right);
        }
    }
}
```

### 4.3.1 平均情况分析
直观上，我们期望所有对树的操作都花费 O(log N) 时间，因为用常数时间在树中降低了一层，这样对其进行操作的树大致减少一半左右。因此所有操作的运行时间都是 O(d) ，其中 d 是包含所访问的项的节点的深度。

接下来证明 **树的所有节点的平均深度为 O(log N)** 。

一棵树的所有节点的深度的和称为 **内部路径长 (internal path length)** 。令 D(N) 是具有 N 个节点的某棵树 T 的内部路径长，D(1) = 0 。一棵 N 节点树由一棵 i 节点左子树和一棵 (N - i - 1) 节点右子树以及深度 0 处的一个根节点组成，其中 0 ≤ i < N ，D(i) 为根的左子树的内部路径长。但是在原树中，所有这些节点都要加深一度。同样的结论对于右子树也成立。因此得到递推关系：

![](插图/4_D(N)=D(i)+D(N-i-1)+N-1.png)

如果所有子树的大小都等可能地出现，这对于二叉查找树是成立的(因为子树的大小值依赖于第一个插入到树中的元素的相对的秩(rank))，但对二叉树不成立。

![](插图/4_D(N)=frac%7B2%7D%7BN%7D%5Bsum_%7Bj=0%7D%5E%7BN-1%7DD(j)%5D+N-1.png)

得到平均值为 D(N) = O(N log N) 。因此任意节点预期的深度为 O(log N) 。这个结果不完全正确，因为删除操作中，我们并不清楚是否所有的二叉查找树都是等可能出现的，特别是上述的删除算法有助于使得左子树比右子树深度深，因为我们总是用右子树的一个节点来代替删除的节点。我们可以通过随机选取右子树的最小元素或左子树的最大元素来代替被删除的元素以消除这种不平衡问题，这明显消除了偏向并使树保持平衡。 

如果向一棵树输入预先排好序的数据，那么一连串的插入操作将花费二次的时间，而链表实现的代价会非常巨大，此时的树也只由那些没有左儿子的节点组成。一种解决办法就是要有一个 **平衡 (balance)** 的附加结构条件：任何节点的深度均不得过深。

一般有两种方法进行处理：其一是平衡二叉树 AVL；其二是放弃平衡条件，但是每次操作后要使用一种规则对树结构进行调整以提高后续操作效率，在二叉查找树的情况下，对于任意单个操作我们不再保证 O(log N) 的时间界，但任意连续 M 次操作在最坏的情况下花费时间 O(M log N) 。