# 4 树
## 4.1 预备知识
### 4.1.1 树的定义
**树 (tree)** 可以用几种方式定义，定义树的一种自然的方式是递归。一棵树是一些节点的集合，这个集合可以是空集；若不是空集，则树由称作 **根 (root)** 的节点 r 以及 0 个或多个非空的 (子) 树组成，这些子树中每一棵的根都被来自根 r 的一条有向的 **边 (edge)** 所连结。

每一棵子树的根叫做根 r 的 **儿子 (child)** ，而 r 是每一棵子树的根的 **父亲 (parent)** 。

在递归定义中可以发现，一棵树是 N 个节点和 N - 1 条边的集合，其中的一个节点叫作根。存在 N - 1 条边的结论是由下面的事实得出：**每条边都将某个节点连接到它的父亲，而除去根节点外每个节点都有一个父亲** 。

每一个节点可以有任意多个儿子，也可能是零个儿子。没有儿子的节点称为 **树叶 (leaf)** ；具有相同父亲的节点为 **兄弟 (siblings)** ；用类似的方法可以定义 **祖父 (grandparent)** 和 **孙子(grandchild)** 关系。

从节点 n<sub>1</sub> 到 n<sub>k</sub> 的 **路径 (path)** 定义为节点 n<sub>1</sub> ，n<sub>2</sub> ，... , n<sub>k</sub> 的一个序列，使得对于 1 ≤ i < k 节点 n<sub>i</sub> 是 n<sub>i + 1</sub> 的父亲。这条路径的 **长 (length)** 是为该路径上的边的条数，即 k - 1 。从每一个节点到它自己有一条长为 0 的路径。注意，在一棵树中从根到每个节点恰好存在一条路径。

对任意节点 n<sub>i</sub>，n<sub>i</sub> 的 **深度 (depth)** 为从根到 n<sub>i</sub> 的唯一的路径的长；因此，根的深度为 0 。n<sub>i</sub> 的 **高 (height)** 是从 n<sub>i</sub> 到一片树叶的最长路径的长；因此所有的树叶的高都是 0 。一棵树的高等于它的根的高。一棵树的深度等于它最深的树叶的深度；该深度总是等于这棵树的高。 

如果存在从 n<sub>1</sub> 到 n<sub>2</sub> 的一条路径，那么 n<sub>1</sub> 是 n<sub>2</sub> 的一位 **祖先 (ancestor)** ，而 n<sub>2</sub> 是 n<sub>1</sub> 的一个 **后裔 (descendant)** 。如果 n<sub>1</sub> ≠ n<sub>2</sub> ，那么 n<sub>1</sub> 是 n<sub>2</sub> 的一位 **真祖先 (proper ancestor)** ，而 n<sub>2</sub> 是 n<sub>1</sub> 的一个 **真后裔 (proper descendant)** 。

### 4.1.2 树的实现
在每一个节点除数据外还要保存一些链，使得该节点的每一个儿子都有一个链指向它。如果直接建立到各(子)节点直接的链接会浪费空间，解决方法是：将每个节点的所有儿子都放在树节点的链表中。

```java
class TreeNode{
    Object element;         // 数据
    TreeNode firstChild;    // 第一儿子
    TreeNode nextSibling;   // 下一兄弟
}
```

![树第一儿子、下一兄弟表示法](插图/4_树第一儿子、下一兄弟表示法.PNG)

### 4.1.3 树的遍历及应用
树的流行用法之一就是在常用操作系统中的目录结构。假如要列出目录中所有文件的名字，输出格式是：深度为 d<sub>i</sub> 的文件将被 d<sub>i</sub> 次跳格(tab) 缩进后打印其名。算法伪码如下：

```java
// 列出分级文件系统中目录
// 递归
private void listAll(int depth){
1    printName(depth);
2    if(isDirectory()){
3        for each file c in this directory (for each child)
4            c.listAll(depth + 1);
     }
}

public void listAll(){
    // 为了显示根时不进行缩进，需要从深度 0 开始
    // 这里的深度是一个内部簿记变量，而不是主调例程能够期望知道的参数
    listAll(0);
}
```

上述遍历策略叫做 **先序遍历 (preorder traversal)** 。在先序遍历中，对节点的处理工作是在它的诸儿子节点被处理之前 (pre) 进行的。该程序运行时，第 1 行对每个节点恰好执行一次，因为每个名字只输出一次。由于第 1 行对每个节点最多执行一次，因此第 2 行也必然对每个节点执行一次。不仅如此，对于每个节点的每一个子节点第 4 行最后只能被执行一次。但是，儿子的个数恰好比节点的个数少 1 。最后，第 4 行每执行一次，for 循环就迭代一次，每当循环结束时再加上一次。因此，在每个节点上总的工作量是常数。如果有 N 个文件名需要输出，则运行时间就是 O(N) 。

另一种遍历树的常用方法是 **后序遍历 (postorder traversal)** 。在后序遍历中，一个节点处的工作是在它的诸儿子节点被计算后进行的。算法伪码如下：

```java
public int size(){
    int totalSize = sizeOfThisFile();

    if(isDirectory()){
        for each file c in this directory (for each child)
            totalSize += c.size();
    }

    return totalSize;
}
```

如果当前对象不是目录，那么 size 只返回它所占用的区块数。否则，被该目录占用的区块数将被加到在其所有子节点 (递归地) 发现的区块数中去。

## 4.2 二叉树
### 4.2.1 二叉树的定义
**二叉树 (binary tree)** 是一棵树，其中每个节点都不能有多于两个的儿子。二叉树的一个性质是一棵平均二叉树的深度比节点个数 N 小得多，这个性质有时很重要。分析表明，其平均深度为 O(N<sup>1/2</sup>) ，而对于特殊类型的二叉树，即 **二叉查找树 (binary search tree)** ，其深度平均值是 O(log N) 。最坏情况下，这个深度是可以大到 N - 1 。

### 4.2.2 二叉树的实现
因为一个二叉树节点最多有两个子节点，所以我们可以保存直接链接到它们的链。树节点的声明在结构上类似于双链表的声明，在声明中，节点就是由 element(元素) 的信息加上两个到其他节点的引用 (left 和 right) 组成的结构。

```java
class BinaryNode{
    Object element;     // 元素信息
    BinaryNode left;    // 左孩子
    BinaryNode right;   // 右孩子
}
```

当画树时，不要显式画出 null 链，具有 N 个节点的每一棵二叉树都将需要 N + 1 个 null 链。

### 4.2.3 例子：表达式树
**表达式树 (expression tree)** 的树叶是 **操作数 (operand)** ,如常数或变量名，而其他的节点为 **操作符 (operator)** 。我们可以通过递归计算左子树和右子树所得到的值应用在根处的运算符上而运算出表达式树的值。

1. **中序遍历 (inorder traversal)**
    * 递归地打印左表达式，然后打印根处的运算符，最后得到右表达式
2. **后序遍历 (postorder traversal)**
    * 递归地打印出左子树、右子树，然后打印运算符
3. **先序遍历 (preorder traversal)**
    * 先打印出运算符，然后递归地打印出右子树和左子树

#### 4.2.3.1 构造表达式树
一次一个符号地读入表达式。如果符号是操作数，那么就建立一个单节点树并将它推入栈中；如果符号是操作符，那么就从栈中弹出两棵树 T<sub>1</sub> 和 T<sub>2</sub> (T<sub>1</sub> 先弹出) 并形成一颗新的树，该树的根就是操作符，它的左、右儿子分别是 T<sub>2</sub> 和 T<sub>1</sub> 。然后将这棵新树压入栈中。

![构造表达式树](插图/4_构造表达式树.png)

## 4.3 查找树 ADT —— 二叉查找树

