# 5 散列
## 5.1 散列的基本思想
理想的散列表数据结构是一个包含一些项的具有固定大小的数组。项可以由一个串 (可以作为关键字) 和其他一些数据域组成。我们把表的大小记作 TableSize ，并将其作为散列的一部分。

散列中，每个关键字被映射到从 0 到 TableSize - 1 这个范围中的某个数，并且被放到适当的单元中，这个映射就叫做散列函数 (hash function) ，理想情况下它的计算很简单，并且应该保证任何两个不同的关键字映射到不同的单元。但这是不可能的，因为单元的数目是有限的，而关键字是用不完的。

我们需要寻找一个散列函数，该函数要在单元之间均匀地分配关键字，还要处理当两个关键字散列到同一值 (即冲突) 时应该如何处理以及如何确定散列表的大小。

## 5.2 散列函数
如果关键字是整数，则一般合理的方法就是直接返回 ``Key mod TableSize`` 。这种情况下，散列函数需要仔细考虑，例如：若 TableSize = 10 而关键字都以 0 为个位时，上述标准的散列函数计算结果无法实现均匀分配。为了避免这样的情况，TableSize 通常为素数。

如果关键字是字符串，有几种散列函数可供选择：
1. 把字符串中字符的 ASCII 码 (或 Unicode 码) 值相加

   ```java
   public static int hash(String key, int tableSize) {
       int hashVal = 0;
   
       for (int i = 0; i < key.length(); i++) {
           hashVal += key.charAt(i);
       }
   
       return hashVal % tableSize;
   }
   ```
   
   上述散列函数实现简单而且能很快计算出答案。但是当表很大时，该函数就无法很好地尽可能均匀分配。假设 TableSize = 10007 ，且所有关键字至多 8 个字符长。由于 ASCII 码的值最多是 127 ，因此散列函数只能假设值在 0 ~ 1016 之间。这显然不是一种均匀的分配。
2. 假设 Key 至少有 3 个字符，值 27 代表英文字母外加一个空格的个数。

   ```java
   public static int hash(String key, int tableSize) {
       return (key.charAt(0) + 27 * key.charAt(1) + 27 * 27 * key.charAt(2)) % tableSize;
   }
   ```
   
   假如前三个字符是随机的，表大小 10007 ，那么得到的分布是较合理的。但是三个字符虽然有 26<sup>3</sup> 种可能组合，但是实际合法的不同的组合数只有 2851 。即使这些组合没有冲突，也只有表的 28% 被真正散列到。
3. 涉及到关键字中的所有字符，根据 Horner 法则计算一个多项式函数，并将结果限制在适当的范围内。

   ```java
   public static int hash(String key, int tableSize) {
       int hashVal = 0;
   
       for (int i = 0; i < key.length(); i++) {
           hashVal = 37 * hashVal + key.charAt(i);
       }
   
       hashVal %= tableSize;
   
       return hashVal < 0 ? hashVal + tableSize : hashVal;
   }
   ```
   
   这个散列函数利用到事实：允许溢出。这可能会引进负数，因此在末尾有附加测试。
   该散列函数就表的分布而言未必是最好的，但极其简单且速度很快。如果关键字特别长，可以挑选其中一部分或只挑选某些位置的字符进行计算，用计算散列函数节省下来的时间来补偿由此产生的对均匀分布的函数的轻微干扰。

## 5.3 分离链接法
**分离链接法 (separate chaining)** 的做法是将散列到同一个值的所有元素保留在一个链表中。如果执行查找，我们需要先通过散列函数确定要遍历哪个链表，在在被确定的链表中进行查找；如果执行插入，我们需要检查相应的链表并将它插在链表头部。

```java
// 分离链接散列表
public class SeparateChainingHashTable<E> {
    public SeparateChainingHashTable() {
        this(DEFAULT_TABLE_SIZE);
    }

    public SeparateChainingHashTable(int size) {
        // 表的大小取素数
        theLists = new LinkedList[nextPrime(size)];
        for (int i = 0; i < theLists.length; i++) {
            theLists[i] = new LinkedList<>();
        }
    }

    public void insert(E x) {
        List<E> whichList = theLists[myhash(x)];
        if (!whichList.contains(x)) {
            // 如果被插入的项已经存在就不执行操作
            whichList.add(x);
            
            if (++currentSize > theLists.length)
                rehash();
        }
    }

    public void remove(E x) {
        List<E> whichList = theLists[myhash(x)];
        if (whichList.contains(x)) {
            whichList.remove(x);
            currentSize--;
        }
    }

    public boolean contains(E x) {
        List<E> whichList = theLists[myhash(x)];
        return whichList.contains(x);
    }

    public void makeEmpty() {
        for (int i = 0; i < theLists.length; i++) {
            theLists[i].clear();
        }
        currentSize = 0;
    }

    private static final int DEFAULT_TABLE_SIZE = 101;

    private List<E>[] theLists;
    private int currentSize;

    private void rehash() {
    }

    private int myhash(E x) {
        int hashVal = x.hashCode();

        hashVal %= theLists.length;
        return hashVal < 0 ? hashVal + theLists.length : hashVal;
    }

    private static int nextPrime(int n) {
        if (n < 2)
            return 2;
        while (!isPrime(++n)) {
        }
        return n;
    }

    private static boolean isPrime(int n) {
        if (n < 2)
            return false;
        else if (n > 2) {
            long len = (long) Math.sqrt(n);
            for (long i = 2; i <= len; i++) {
                if (n % i == 0)
                    return false;
            }
        }
        return true;
    }
}
```

我们定义散列表的 **装填因子 (load factor) λ** 为散列表汇总元素个数和表大小之比。上述例子中，λ = 1.0 。链表的平均长度为 λ 。执行一次查找所需要的工作是计算散列函数值所需要的常数时间加上遍历链表所用的时间。在一次不成功的查找中，要考察的节点数平均为 λ ；一次成功的查找需要遍历大约 1 + (λ/2)<sup>1/2</sup > 个链。可以看出散列表的大小其实并不重要，更重要的是装填因子。分离链接散列法的一般法则是使得表的大小与预料的元素个数大致相等 (λ ≈ 1) 。当装填因子超过 1 时，我们需要通过 rehash 函数扩大散列表的大小，后续会展开说明。