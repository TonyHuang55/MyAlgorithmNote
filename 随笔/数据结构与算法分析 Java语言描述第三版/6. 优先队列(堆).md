# 6 优先队列(堆)

## 6.1 模型
优先队列是允许至少下列两种操作的数据结构：insert、deleteMin 。其中 deleteMin 的工作是找出、返回并删除优先队列中最小的元素。insert 操作等价于 enqueue (入队) ，而 deleteMin 则是队列运算 dequeue (出队) 在优先队列中的等价操作。

## 6.2 一些简单的实现
有几种明显的办法可用于实现优先队列。我们可以使用一个简单链表在表头以 O(1) 执行插入操作，并遍历该链表以删除最小元，这又需要 O(N) 时间；另一种方法是始终让链表保持排序状态：这使得插入代价高昂 (O(N)) 而 deleteMin 花费低廉 (O(1)) 。

另一种实现优先队列的方法是使用二叉查找树，它对这两种操作的平均运行时间都是 O(log N) 。尽管插入是随机的，而删除则不是，但这个结论还是成立的。记住我们删除的唯一元素是最小元。反复取出左子树中的节点似乎会损害树的平衡，使得右子树加重。然而右子树是随机的。在最坏的情况下，即 deleteMin 将左子树删空的情形下，右子树拥有的元素最多也就是它应具有的两倍。这只是在期望的深度上加了一个小常数。注意，通过使用一棵平衡树，可以把这个界变成最坏情形的界：这将防止出现坏的插入序列。

使用查找树可能有些过分，因为它支持许许多多并不需要的操作。我们将要使用的基本的数据结构不需要链，它以最坏情形时间 O(log N) 支持上述两种操作。插入操作实际上将花费常数平均时间，若无删除操作的干扰，该结构的实现将以线性时间建立一个具有 N 项的优先队列。然后，我们将讨论如何实现优先队列以支持有效的合并。这个附加的操作似乎有些复杂，它显然需要使用链接的结构。

## 6.3 二叉堆
**二叉堆 (binary heap)** 的使用对于优先队列的实现相当普遍，以至于当堆 (heap) 这个词不加修饰地用优先队列的上下文时，一般都是指数据结构的这种实现。像二叉查找树一样，堆也有两个性质，即结构性和堆序性。恰似 AVL 树，对堆的一次操作可能破坏这两个性质中的一个，因此堆的操作必须到堆的所有性质都被满足时才能终止。

### 6.3.1 结构性质
堆是一棵被完全填满的二叉树，有可能的例外是在底层，底层上的元素从左到右填入。容易证明的是，一棵高为 h 的完全二叉树有 2<sup>h</sup> 到 2<sup>h + 1</sup> - 1 个节点，这意味着完全二叉树的高是 log N ，显然它是 O(log N) 。

由于完全二叉树这样的规律，所以它可以用一个数组表示而不需要使用链。对于数组中任一位置 i 上的元素，其左儿子在位置 2i 上，右儿子在左儿子后的单元 (2i + 1) 中，它的父亲则在位置 i/2 上。这样遍历该树所需要的操作极其简单，在大部分计算机上运行很可能非常快。这种实现方法的唯一问题在于，最大的堆大小需要事先估计。

因此一个堆结构将由一个 (Comparable 对象的) 数组和一个代表当前堆的大小的整数组成。

### 6.3.2 堆序性质
让操作快速执行的性质是 **堆序性质 (heap-order property)** 。由于我们想要快速找出最小元，因此最小元应该在根上。如果我们考虑任意子树也应该是一个堆，那么任意节点就应该小于它的所有后裔。

应用这个逻辑，我们得到堆序性质。在一个堆中，对于每个节点 X ，X 的父亲中的关键字系小于或等于 X 中的关键字，根节点除外。此时最小元总可以在根处找到，可以以常数时间得到附加操作 findMin 。

### 6.3.3 基本的堆操作
```java
public class BinaryHeap<E extends Comparable<? super E>> {
    public BinaryHeap() {
        this(DEFAULT_CAPACITY);
    }

    public BinaryHeap(int capacity) {
        currentSize = 0;
        array = (E[]) new Comparable[capacity + 1];
    }

    public BinaryHeap(E[] items) {
        currentSize = items.length;
        array = (E[]) new Comparable[(currentSize + 2) * 11 / 10];
        int i = 1;
        for (E item : items) {
            array[i++] = item;
        }
        buildHeap();
    }

    // 上滤策略：新元素在堆中上滤知道找出正确的位置

    // 我们本可以使用 insert 例程反复执行交换操作直至建立正确的序来实现上滤，可是一次交换需要 3 条赋值语句
    // 如果一个元素上滤 d 层，那么由于交换而执行的赋值次数就达到 3d ，而我们这里的方法却只用到 d + 1 次赋值
    // 如果欲插入的元素是新的最小元从而一直上滤到根处，那么这种插入的时间将长达 O(log N)
    public void insert(E x) {
        if (currentSize == array.length - 1)
            enlargeArray(array.length * 2 + 1);

        // 在下一个可用位置创建一个空穴
        int hole = ++currentSize;
        // 如果 x 可以放在该空穴并不破坏堆的序，则插入完成
        // 否则将空穴的父节点上的元素移入空穴中，这样空穴就朝着根的方向上冒一步，继续该过程直到 x 能被放入空穴中为止
        for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2) {
            array[hole] = array[hole / 2];
        }
        array[hole] = x;
    }

    public E findMin() {
        if (isEmpty())
            return null;
        return array[1];
    }

    public E deleteMin() {
        if (isEmpty())
            throw new UnderflowException();

        E minItem = findMin();
        array[1] = array[currentSize--];
        percolateDown(1);

        return minItem;
    }

    public boolean isEmpty() {
        return currentSize == 0;
    }

    public void makeEmpty() {
        currentSize = 0;
        for (E e : array) {
            e = null;
        }
    }


    private static final int DEFAULT_CAPACITY = 10;

    private int currentSize;
    private E[] array;


    // 下滤
    // 该操作的最坏运行时间为 O(log N) ，平均而言，被放到根处的元素几乎下滤到堆的底层，因此平均运行时间为 O(log N)
    private void percolateDown(int hole) {
        int child;
        E tmp = array[hole];

        for (; hole * 2 <= currentSize; hole = child) {
            child = hole * 2;
            // 当堆中存在偶数个元素的时候可能会发生错误
            // 解决方法是：始终保证算法把每个节点都看成两个儿子
            // 当堆的大小为偶数时，在每个下滤开始处，可将其值大于堆中任何元素的标记放到堆的终端后面的位置上
            // 虽然这不再需要测试右儿子的存在性，但是还是需要测试何时达到底层，因为对每一片树叶算法将需要一个标记
            if (child != currentSize &&
                    array[child + 1].compareTo(array[child]) < 0)
                child++;
            if (array[child].compareTo(tmp) < 0)
                array[hole] = array[child];
            else
                break;
        }
        array[hole] = tmp;
    }

    private void buildHeap() {
        for (int i = currentSize / 2; i > 0; i--) {
            percolateDown(i);
        }
    }

    private void enlargeArray(int newSize) {
        E[] old = array;
        array = (E[]) new Comparable[newSize];
        for (int i = 0; i < old.length; i++) {
            array[i] = old[i];
        }
    }
}
```

定理：包含 2<sup>h + 1</sup> - 1 个节点、高为 h 的理想二叉树 (perfect binary tree) 的节点的高度的和为 2<sup>h + 1</sup> - 1 - (h + 1)